forked from https://github.com/peng-zhihui/ElectronBot/tree/main/2.Firmware/ServoDrive-fw-ll

commit/573c6a970e32bb4cdea8ae1355b5403c2718fc7b

这个是智能舵机的LL库版本，代码体积得到优化，使用vscode和platformio开发，开发环境和编译参考[这个视频](https://www.bilibili.com/video/BV1US4y1P7Xr/)

包含舵机的电位器ADC采样，I2C从机通信和协议解析，电机控制的PWM输出，以及PID闭环算法实现。

#### 舵机I2C协议

魔改后的舵机通过I2C接口和控制板进行通信，STM32F4的控制板为主机，舵机为从机。通信的过程始终是主机发起的，主机首先下发位置、参数等指令，然后即时取回相关数据完成一个通信来回。

每个舵机作为从机接收两个地址的指令：**自己的ID号**，以及**0号广播**。广播用于在没有给舵机设置地址的时候作为通配地址使用（比如你刚烧写完舵机固件，此时舵机的Flash是没有储存自己的ID的，只能通过0号地址通信）。

**值得注意的是：舵机和主机的上电需要有先后顺序，一定要先让从机初始化完成开始监听数据，再让主机发送指令！**

> 如果主机发送指令的时候从机不响应，或者多个舵机地址相同同时响应，都可能引起通信错误，因此需要保证上述的顺序。
>
> 由于硬件上主机和舵机上电都是同时的，所以在主机的固件代码中，有一个延时2S的代码（其实可以不用那么久），就是等待舵机都上电初始化完成再开始通信。
>
> 调试的时候，一个舵机一个舵机调试，注释掉其他未连接的舵机的通信代码，不然也会造成轮询等待超时。

关于舵机的指令含义，感谢 **[leazer](https://github.com/leazer)** 同学在Issues整理的表格：

![image](https://user-images.githubusercontent.com/9492648/209342973-c151cf59-0627-44c6-9c99-1f818d6e7081.png)

> 指令后续可能会更新。

#### 关于舵机的改造？

通常的RC-Servo都是使用电位器进行绝对角度的测量的，因此我在驱动板中也是使用ADC读取电位器的电压值转换成角度反馈，而驱动芯片使用了我找到的封装最小的一个芯片FM116B。大家改造舵机的时候，注意区分电机两根接线的方向，如果调试发现电机不闭环的话，可能需要交换一下接线顺序。

#### 舵机固件和基本的调试方法

1）舵机第一次调试时，会默认初始化本地I2C地址为12，并且在收到主控的Enable信号前不会有动作。

2）舵机第一次连接主控时，【需要一个个配置地址】，一次只连一个，在主控用0X00地址发送 SetId指令。 比如：头部舵机配置为0X02，断电重启，用主控测试能否用0X02连接到舵机。 然后再插第二个舵机。one by one.

3）4.3g舵机用默认PD参数，和默认50%扭矩限制，能正常控制， 但是9g舵机（底座那个），需要把扭矩限制调到0.7以上，P参数调大一点，控制效果会好一点。

4）舵机的程序，我发现偶尔会有I2C卡死收不到中断的问题。后来我把控制函数从中断中拿出来，在Main While里200hz执行会明显有提升。不知道其他朋友们有没有遇到过。我用MDK编译了两个固件，有需要的朋友可以下载试试。（F030F4P6便宜很多）
